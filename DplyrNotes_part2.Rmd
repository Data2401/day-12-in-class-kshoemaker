---
title: "Dplyr - Advanced Notes"
author: "Dr. Shoemaker"
date: "DATA 2401"
output:
  slidy_presentation:
    fig_height: 3
    fig_width: 3
  pdf_document: default
  ioslides_presentation: default
  beamer_presentation: default
---



# Refresh on last class: 

* dplyr : new language to work with data.frames
* Verbs learned: `filter`, `select`,  `arrange`, and `mutate`
  * `filter` - chooses *rows* that meet criteria.
  * `select` - chooses *columns* that meet criteria.
  * `arrange` - arranges the dataset by the ordering of a chosen column.
  * `mutate` - creates a new column as specified.
  
  
# Quick Practice from Yesterday

In the "in class" repo for the day, stop when you see "Exercises"
  

# New Material: 

## Groups and summaries with `group_by()` and `summarize()`

```{r, message = F, warning = F}
### message = F and warning = F suppress the messages and warnings.
library(tidyverse)
library(gapminder) ## loading the data package
my_gap <- gapminder ## saving a copy of the data
glimpse(my_gap)
```


Questions like "What country experienced the sharpest 5-year rise in life expectancy?" are very natural questions to ask. But, it's a difficult question to answer if you're just handed a dataframe and are working in a language that isn't data focused. 

`dplyr` has tools that help with this kind of problem:

1. `group_by()` gives extra structure to your dataset through grouping information, and you can then do computations within those groups.
2. `summarize()` takes a dataset with $n$ observations, computes the summaries you ask for, then returns a dataset with 1 observation. (n to 1)
3. Window functions take a dataset with $n$ observations and return a dataset with $n$ observations (think like ordering or ranking) (n to n)
4. `mutate()` and `summarize()` respects the groupings


# Starting easy: Counting. 

Count the obervations by continent. 

```{r}
count_data <- my_gap %>%  group_by(continent) %>% summarize(n_count = n())
glimpse(count_data)

```

Last class, we did this with a different function, `table()`

```{r}
table(my_gap$continent)
str(table(my_gap$continent))
```

The problem here is that this object is of class `table`, so I'd have to do some fiddly stuff to work with it. The continent names in the table are just dimension names instead of being their own vector. 

---

Another option is `tally()`

```{r}
my_gap  %>% group_by(continent) %>% tally()
tally(group_by(my_gap, continent))

```

And even more convenient, `count()`

```{r}
my_gap %>% count(continent) 
count(my_gap, continent)
```

And, count can be `arrange`d

```{r}
my_gap %>% count(continent) %>% arrange(n)
```

---


And if we want a tally of unique countries for each continent? Summarize can have multiple summaries! The function `n_distinct()` counts the distinct objects inside the groups you're looking at. 

```{r}
my_gap %>%
 group_by(continent) %>%
  summarize(n = n(),
            n_countries = n_distinct(country), 
            n_years = n_distinct(year))

```

---

What if I want the largest 5 values for each group? Or the smallest? 

`slice_xxx()` has lots of useful options that work with (or without) `group_by()` to give the requested values. 

This is better than using `arrange()` followed by `head()`, because the slice options account for ties - if there are 3 rows that are "tied" for 5th largest, slice will return all of them and head will only give the one in the 5th row. 

```{r}
library(palmerpenguins)

# the 5 heaviest penguins on each island
penguins %>% 
  group_by(island) %>% 
  slice_max(body_mass_g, n = 5)
# notice how the result has 16 rows - because of a tie! 

penguins %>% 
  group_by(island) %>% 
  slice_min(body_mass_g, n = 5)
```

# Using Rank

Consider if I wanted to create some metric about the "biggest" penguin. 

I could use a window function, `rank()`, to give me their ranks and add them up and find the smallest value. 

```{r}
penguins %>% mutate(rank_bills = rank(bill_length_mm), .keep = "used") %>% arrange(rank_bills)

penguins %>% 
  mutate(rank_bills = rank(bill_length_mm) +   rank(bill_depth_mm), 
         rank_flippers = rank(flipper_length_mm),
         rank_mass = rank(body_mass_g),
         rank_sum = rank_bills + rank_flippers + rank_mass
      ) %>% 
  arrange(rank_sum)

# notice I'm using variables I just made in the same mutate. 
```


# Ways to summarize

All of the functions we've been using to make summaries can be used in summarise! `mean`, `median`, `var`, `sd`, `min`, `max`. And since we can use summarize on the groupings... now we can do this more powerfully. 

Suppose we want to see the average of our new "rank" by species
```{r}
penguins %>% 
  mutate(rank_bills = rank(bill_length_mm) + rank(bill_depth_mm), 
         rank_flippers = rank(flipper_length_mm),
         rank_mass = rank(body_mass_g),
         rank_sum = rank_bills + rank_flippers + rank_mass
      ) %>% 
  group_by(species) %>% 
  summarise(mean(rank_sum))
```

---

Find the average mass by sex of penguin: 

```{r}
penguins %>%
  group_by(sex) %>%
  summarize(avg_mass = mean(body_mass_g))

```

---

But, we already know that the mass varies by species, so that's not really a great thing to do, statistically. 

Doing this for only one species would make this slightly better, so lets add in a `filter()`

```{r}
penguins %>% 
  filter(species == "Adelie") %>% 
  group_by(sex) %>%
  summarize(avg_mass = mean(body_mass_g))
```

If we're interested in all the penguins, add a second grouping variable, which will compute the summary for every (A,B) pair of variables

```{r}
penguins %>% 
  group_by(sex, species) %>%
  summarize(avg_mass = mean(body_mass_g))
```


---

What if we want the same summary function on multiple variables? `across()` is a way to do this. Let's take the average and median values of a few of the size variables for size and species.


```{r}
penguins %>%
  group_by(sex, species) %>%
  summarise(across(c(bill_length_mm, bill_depth_mm, flipper_length_mm), mean))
```

Let's take the average and median values of a few of the size variables for size and species.

```{r}
penguins %>%
  group_by(sex, species) %>%
  summarise(across(c(bill_length_mm, bill_depth_mm, flipper_length_mm), list(mean, median)))
```

---

This is super flexible on the output:

```{r}
# name the function, which names the output
penguins %>%
  group_by(sex, species) %>%
  summarise(across(ends_with("mm"), list(mean = mean, median = median)))
```

Or you can add a special structure with an argument

```{r}
penguins %>%
  group_by(sex, species) %>%
  summarise(  across(ends_with("mm"), list(mean = mean, median = median), .names = "{.fn}_{.col}"))
```




And, I want the columns for the same data next to each other, I can use `select()`
```{r}
penguins %>%
  group_by(sex, species) %>%
  summarise(across(ends_with("mm"), list(mean = mean, median = median))) %>% 
  select(sex, species, ends_with("mean"), ends_with("median"))
```


 
---

Use summarize to find the min and max weight  *by island*, *in females*. 

```{r}
penguins %>%
  filter(sex == "female") %>%
  group_by(island) %>%
  summarize(min_weight = min(body_mass_g), max_weight = max(body_mass_g))

penguins %>% 
  filter(sex == "female") %>%
  group_by(island) %>%
  summarize(across(body_mass_g, list(min = min, max = max), .names = "{.fn}_weight"))
```


# Exercise: 

Head to the rmd for today's in class activity to complete! 



# Group and Mutate

Sometimes you don't want to collapse your $n$ rows to one datapoint, but instead keep the groups and compute with those. 


For starters, lets make a variable that is years of life expectancy gained (lost) relative to 1952. 

How do we do this? Group by country, use mutate to make this new variable. We use the function `first()` inside the mutate to get the first value of the vector *inside that group*

```{r}
my_gap %>% 
  group_by(country) %>% 
  select(country, year, lifeExp) %>% 
  mutate(lifeExp_gain = lifeExp - first(lifeExp)) %>%  
    ## the difference between the current lifeExp and lifeExp in 1952
  filter(year < 1963)
```


---

Back to our min/max in Europe. Let's do this again, but keeping the names of the countries with the life expectancy:

```{r}
my_gap %>%
  filter(continent == "Europe") %>%
  select(year, country, lifeExp) %>%
  group_by(year) %>%
  filter(min_rank(desc(lifeExp)) < 2 | min_rank(lifeExp) < 2) %>% 
  # min_rank() returns the rank of each country’s observed life expectancy. 
  # min desc and min ascending gives the highest and lowest
  arrange(year) 

```

## Exercise 2:

# And the finale... 

> What country experienced the sharpest 5-year rise in life expectancy? 

The data is in 5 years, so we're looking at differences between adjacent timepoints. 

For this, we'll need the `lag()` function, which finds the previous value in a vector. (There is also a function `lead()`, which finds the next one.)
 
```{r}
my_gap %>%
  select(country, year, continent, lifeExp) %>%
  group_by(continent, country) %>%
  ## within country, take (lifeExp in year i) - (lifeExp in year i - 1)
  ## positive means lifeExp went up, negative means it went down
  mutate(le_delta = lifeExp - lag(lifeExp)) %>% 
  ## within country, retain the highest lifeExp change = largest
  summarize(best_le_delta = max(le_delta, na.rm = TRUE)) %>% 
  ## within continent, retain the row with the highest best_le_delta
  top_n(1, wt = best_le_delta) %>%
  arrange(best_le_delta)
```


So, here's the deal with this. I could not just do this on the fly. These are complex solutions to complex problems. Sit with this for a bit. Unpack it. See if you can follow what's going on. 

# Today's lab

There is a wrap up lab in today's in class rmd! 

--- 

*Note: These notes were adapted from https://stat545.com, provided under the creative commons license (https://creativecommons.org/licenses/by-sa/4.0/legalcode), thus these notes also fall under the Creative Commons license through the ShareAlike policy. Portions of the notes also adapted from Mine Çetinkaya-Rundel's STAT199 at Duke University, https://www2.stat.duke.edu/courses/Spring18/Sta199/ *
